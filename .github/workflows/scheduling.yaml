name: "Scheduling"

on:
  workflow_run:
    workflows: [Workload]
    types: [completed]
    branches:
      - main
      - release

jobs:
  scheduler:
#    if: ${{ !github.event.workflow_run
#            || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Run C/D on yet-another-branch
        uses: actions/github-script@v6
        #if: ${{ github.event.workflow_run.head_branch == 'yet-another-branch' }}
        with:
          script: |
            const branchesToService = ["main", "release"];

            const workloadWorkflow = "workload.yaml";

            const inProgressWorkflowRunListResponse = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workloadWorkflow,
              per_page: 0,
              exclude_pull_requests: true,
              status: "in_progress"
            });

            const queuedWorkflowRunListResponse = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workloadWorkflow,
              per_page: 0,
              exclude_pull_requests: true,
              status: "queued"
            });

            const activeWorkflowRunCount =
              inProgressWorkflowRunListResponse.data.total_count
              + queuedWorkflowRunListResponse.data.total_count;

            console.log("activeWorkflowRunCount=", activeWorkflowRunCount);

            if (activeWorkflowRunCount) {
              console.log(`terminating: ${inProgressWorkflowRunListResponse.data.total_count} workflow runs "in_progress", `
                + `${queuedWorkflowRunListResponse.data.total_count} "queued"`);
              return 0;
            }

            console.log("branchesToService" + JSON.stringify(branchesToService));

            const completedWorkflowRunListResponse =
              await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workloadWorkflow,
                per_page: branchesToService.length,
                exclude_pull_requests: true,
                status: "completed"
              });

            const completedWorkflowRuns = completedWorkflowRunListResponse.data.workflow_runs;

            let nextBranchToService = null;
            for (const b of branchesToService) {
              if (!completedWorkflowRuns.find(wr => wr.head_branch == b)) {
                nextBranchToService = b;
                break;
              }
            }

            if (nextBranchToService == null) {
              console.log(
                "all branches services this cycle already, will take first one from "
                + JSON.stringify(completedWorkflowRuns.map(wr => wr.head_branch)));

              nextBranchToService = completedWorkflowRuns[completedWorkflowRuns.length-1].head_branch;
            }

            if (nextBranchToService) {
              console.log("scheduling a run to service next branch: " + nextBranchToService);

              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workloadWorkflow,
                ref: nextBranchToService
              });
            }
